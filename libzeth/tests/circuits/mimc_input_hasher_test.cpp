// Copyright (c) 2015-2022 Clearmatics Technologies Ltd
//
// SPDX-License-Identifier: LGPL-3.0+

#include "libzeth/circuits/mimc/mimc_input_hasher.hpp"
#include "libzeth/circuits/mimc/mimc_mp.hpp"
#include "libzeth/circuits/mimc/mimc_selector.hpp"

#include <gtest/gtest.h>
#include <libff/algebra/curves/bls12_377/bls12_377_pp.hpp>
#include <libff/algebra/curves/bw6_761/bw6_761_pp.hpp>

namespace
{

template<typename ppT>
void test_mimc_input_hasher_simple(
    const std::vector<libff::Fr<ppT>> &input_values,
    const libff::Fr<ppT> &expected_digest,
    const std::string &test_name)
{
    using Field = libff::Fr<ppT>;
    using comp_fn = libzeth::mimc_compression_function_gadget<Field>;
    using input_hasher = libzeth::mimc_input_hasher<Field, comp_fn>;

    libsnark::protoboard<Field> pb;

    // Public input: hash of multiple values
    libsnark::pb_variable<Field> hashed_inputs;
    hashed_inputs.allocate(pb, "hashed_inputs");
    pb.set_input_sizes(1);

    // Values to hash
    libsnark::pb_variable_array<Field> orig_inputs;
    orig_inputs.allocate(pb, input_values.size(), "orig_inputs");

    // Input hasher
    input_hasher hasher(pb, orig_inputs, hashed_inputs, "hasher");

    // Constraints
    hasher.generate_r1cs_constraints();

    // Witness
    for (size_t i = 0; i < input_values.size(); ++i) {
        pb.val(orig_inputs[i]) = input_values[i];
    }
    hasher.generate_r1cs_witness();

    ASSERT_EQ(expected_digest, pb.val(hashed_inputs));
    ASSERT_EQ(expected_digest, input_hasher::compute_hash(input_values));
    ASSERT_TRUE(pb.is_satisfied());

    printf("%s: %zu constraints", test_name.c_str(), pb.num_constraints());
}

TEST(MiMCInputHasherTest, SimpleInputValuesBLS12_377)
{
    using pp = libff::bls12_377_pp;
    using Field = libff::Fr<pp>;

    // Test data generated by test_input_hasher_mimc_bls12_377:
    //   $ python
    //   >>> from zeth.core.mimc import MiMCBLS12_377
    //   >>> from zeth.core.input_hasher import InputHasher
    //   >>> InputHasher(MiMCBLS12_377()).hash([0,1,-1,2,-2])
    const std::vector<Field> simple_values{{
        Field::zero(),
        Field::one(),
        -Field::one(),
        Field("2"),
        -Field("2"),
    }};
    const Field expect_hash("24413724837428607704066638210762875107426186849414"
                            "55909840195654797701248623");
    test_mimc_input_hasher_simple<pp>(
        simple_values, expect_hash, "test_mimc_input_hasher_5_vals_bls12_377");
}

TEST(MiMCInputHasherTest, SimpleInputValuesBW6_761)
{
    using pp = libff::bw6_761_pp;
    using Field = libff::Fr<pp>;

    const std::vector<Field> simple_values{{
        Field::zero(),
        Field::one(),
        -Field::one(),
        Field("2"),
        -Field("2"),
    }};
    const Field expect_hash(
        "5651882415653839759306925885453719303796998645116649334173640136123407"
        "7677299403608616888793789940721658098910083");
    test_mimc_input_hasher_simple<pp>(
        simple_values, expect_hash, "test_mimc_input_hasher_5_vals_bls12_377");
}

} // namespace

int main(int argc, char **argv)
{
    libff::bls12_377_pp::init_public_params();
    libff::bw6_761_pp::init_public_params();
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
