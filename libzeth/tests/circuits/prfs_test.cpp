// Copyright (c) 2015-2021 Clearmatics Technologies Ltd
//
// SPDX-License-Identifier: LGPL-3.0+

#include "libzeth/circuits/blake2s/blake2s.hpp"
#include "libzeth/circuits/circuit_types.hpp"
#include "libzeth/circuits/circuit_utils.hpp"
#include "libzeth/circuits/prfs/prf.hpp"
#include "libzeth/core/utils.hpp"
#include "zeth_config.h"

#include <gtest/gtest.h>
#include <libsnark/common/data_structures/merkle_tree.hpp>

using namespace libsnark;
using namespace libzeth;

using pp = defaults::pp;
using Field = defaults::Field;

using Hash = BLAKE2s_256<Field>;

namespace
{

TEST(TestPRFs, TestGenZeroes)
{
    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> ZERO;
    ZERO.allocate(pb, "zero");
    pb.val(ZERO) = Field::zero();

    libsnark::pb_variable_array<Field> zeroes256 =
        variable_array_from_bit_vector(
            pb,
            {
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
                0, 0, 0, 0, 0, 0, 0, 0, //
            },
            "zeroes256");

    libsnark::pb_variable_array<Field> result =
        gen_256_zeroes<Field, Hash>(ZERO);
    ASSERT_EQ(result.get_bits(pb), zeroes256.get_bits(pb));
}

TEST(TestPRFs, TestPRFAddrApkGadget)
{
    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> ZERO;
    ZERO.allocate(pb, "zero");
    pb.val(ZERO) = Field::zero();

    // a_sk corresponds to the number:
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    libsnark::pb_variable_array<Field> a_sk = variable_array_from_bit_vector(
        pb,
        {
            0, 0, 0, 0, 1, 1, 1, 1, // 0F
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1  // FF
        },
        "sk");

    // a_pk should equal:
    // 0x208f95ee37621c3c2d9c74be39bf687c47e84c679b88df270858067c08a16daf Since
    // a_pk = blake2s( 1100 || [a_sk]_252 || 0^256), where:
    //  - a_sk =
    //   0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    //  - 0^256 =
    //   0x0000000000000000000000000000000000000000000000000000000000000000
    //   Note:
    // This test vector has been generated by using the hashlib blake2s
    // function Note: (we want to make sure that we generate the same digests
    // both on-chain and off-chain)
    libsnark::pb_variable_array<Field> a_pk_expected =
        variable_array_from_bit_vector(
            pb,
            bit_vector_from_hex("2390c9e5370be7355f220b29caf3912ef970d828b73976"
                                "ae9bfeb1402ce4c1f9"),
            "expected");

    std::shared_ptr<libsnark::digest_variable<Field>> result(
        new digest_variable<Field>(pb, Hash::get_digest_len(), "result"));
    PRF_addr_a_pk_gadget<Field, Hash> prf_apk_gadget(pb, ZERO, a_sk, result);

    prf_apk_gadget.generate_r1cs_constraints();
    prf_apk_gadget.generate_r1cs_witness();

    bool is_valid_witness = pb.is_satisfied();
    ASSERT_TRUE(is_valid_witness);
    ASSERT_EQ(result->get_digest(), a_pk_expected.get_bits(pb));
}

TEST(TestPRFs, TestPRFNFGadget)
{
    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> ZERO;
    ZERO.allocate(pb, "zero");
    pb.val(ZERO) = Field::zero();

    // a_sk corresponds to the number:
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    libsnark::pb_variable_array<Field> a_sk = variable_array_from_bit_vector(
        pb,
        {
            0, 0, 0, 0, 1, 1, 1, 1, // 0F
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1  // FF
        },
        "sk");

    // hex: 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    libsnark::pb_variable_array<Field> rho = variable_array_from_bit_vector(
        pb,
        {
            0, 0, 0, 0, 1, 1, 1, 1, // 0F
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1  // FF
        },
        "rho");

    // nf should equal:
    // 4a5f4f585dda39cc597366f9172bae924d22e832487e12e76742dbab9393b620
    // nf = blake2sCompress( 1110 || [a_sk]_252 || rho)
    // a_sk:
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    // rho:
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    // Note: This test vector has been generated by using the hashlib
    // blake2s function (we want to make sure that we generate the same digests
    // both on-chain and off-chain)
    libsnark::pb_variable_array<Field> nf_expected =
        variable_array_from_bit_vector(
            pb,
            bit_vector_from_hex("ea43866d185e1bdb84713b699a2966d929d1392488c010"
                                "c603e46a4cb92986f8"),
            "expected");

    std::shared_ptr<libsnark::digest_variable<Field>> result(
        new digest_variable<Field>(pb, Hash::get_digest_len(), "result"));

    PRF_nf_gadget<Field, Hash> prf_nf_gadget(pb, ZERO, a_sk, rho, result);

    prf_nf_gadget.generate_r1cs_constraints();
    prf_nf_gadget.generate_r1cs_witness();

    bool is_valid_witness = pb.is_satisfied();
    ASSERT_TRUE(is_valid_witness);
    ASSERT_EQ(result->get_digest(), nf_expected.get_bits(pb));
}

TEST(TestPRFs, TestPRFPKGadget)
{
    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> ZERO;
    ZERO.allocate(pb, "zero");
    pb.val(ZERO) = Field::zero();

    // a_sk corresponds to the number:
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    libsnark::pb_variable_array<Field> a_sk = variable_array_from_bit_vector(
        pb,
        {
            0, 0, 0, 0, 1, 1, 1, 1, // 0F
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1  // FF
        },
        "sk");

    // h_sig: 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    libsnark::pb_variable_array<Field> hsig = variable_array_from_bit_vector(
        pb,
        {
            0, 0, 0, 0, 1, 1, 1, 1, // 0F
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1  // FF
        },
        "hsig");

    // h_i should equal:
    // 7ea1525fdbf9462c5144796937e1f80b9dad42369f7d4987c436b2f79257f9ac h_i =
    // blake2sCompress( 0i00 || [a_sk]_252 || h_sig)
    // a_sk =
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    // h_sig =
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    // Note: This test vector has been generated by using the hashlib
    // blake2s function (we want to make sure that we generate the same digests
    // both on-chain and off-chain)
    libsnark::pb_variable_array<Field> h_expected0 =
        variable_array_from_bit_vector(
            pb,
            bit_vector_from_hex("8527fb92081cf832659a188163287f98b8c919401ba619"
                                "d6ebd30dc0f1aedeff"),
            "expected0");

    std::shared_ptr<libsnark::digest_variable<Field>> result0(
        new digest_variable<Field>(pb, Hash::get_digest_len(), "result"));

    PRF_pk_gadget<Field, Hash> prf_pk_gadget0(
        pb, ZERO, a_sk, hsig, size_t(0), result0);

    prf_pk_gadget0.generate_r1cs_constraints();
    prf_pk_gadget0.generate_r1cs_witness();

    libsnark::pb_variable_array<Field> h_expected1 =
        variable_array_from_bit_vector(
            pb,
            bit_vector_from_hex("aea510673ff50225bec4bd918c102ea0c9b117b9353464"
                                "4ee70b74522b204b29"),
            "expected1");

    std::shared_ptr<libsnark::digest_variable<Field>> result1(
        new digest_variable<Field>(pb, Hash::get_digest_len(), "result"));

    PRF_pk_gadget<Field, Hash> prf_pk_gadget1(
        pb, ZERO, a_sk, hsig, size_t(1), result1);

    prf_pk_gadget1.generate_r1cs_constraints();
    prf_pk_gadget1.generate_r1cs_witness();

    bool is_valid_witness = pb.is_satisfied();
    ASSERT_TRUE(is_valid_witness);
    ASSERT_EQ(result0->get_digest(), h_expected0.get_bits(pb));
    ASSERT_EQ(result1->get_digest(), h_expected1.get_bits(pb));
}

TEST(TestPRFs, TestPRFRhoGadget)
{
    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> ZERO;
    ZERO.allocate(pb, "zero");
    pb.val(ZERO) = Field::zero();

    // phi corresponds to the number:
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    libsnark::pb_variable_array<Field> phi = variable_array_from_bit_vector(
        pb,
        {
            0, 0, 0, 0, 1, 1, 1, 1, // 0F
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            0, 0, 0, 0, 0, 0, 0, 0, // 00
            1, 1, 1, 1, 1, 1, 1, 1  // FF
        },
        "phi");

    // hsig: 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF
    libsnark::pb_variable_array<Field> hsig = variable_array_from_bit_vector(
        pb,
        {
            0, 0, 0, 0, 1, 1, 1, 1, // 0F
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1, // FF
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            0, 0, 0, 0, 0, 0, 0, 0, //
            1, 1, 1, 1, 1, 1, 1, 1  // FF
        },
        "hsig");

    // rho should equal:
    // a87c47a6c721bdbbb4aa8875c2aa72d4db31b9526aa920656049e00786f7f8a4
    // rho = blake2sCompress( 0i10 || [phi]_252 || h_sig) phi:
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF hsig:
    // 0x0F000000000000FF00000000000000FF00000000000000FF00000000000000FF Note:
    // This test vector has been generated by using the hashlib blake2s
    // function (we want to make sure that we generate the same digests both
    // on-chain and off-chain)
    libsnark::pb_variable_array<Field> rho_expected0 =
        variable_array_from_bit_vector(
            pb,
            bit_vector_from_hex("d7b7c4536bbba1aaca684706ba0df170af95515d573ad9"
                                "3e30015e1c40ebc539"),
            "expected0");

    std::shared_ptr<libsnark::digest_variable<Field>> result0(
        new digest_variable<Field>(pb, Hash::get_digest_len(), "result"));

    PRF_rho_gadget<Field, Hash> prf_rho_gadget0(
        pb, ZERO, phi, hsig, size_t(0), result0);

    prf_rho_gadget0.generate_r1cs_constraints();
    prf_rho_gadget0.generate_r1cs_witness();

    libsnark::pb_variable_array<Field> rho_expected1 =
        variable_array_from_bit_vector(
            pb,
            bit_vector_from_hex("bb17f6088e47a8b2ac8e3d57588d52fed63079dc2b7045"
                                "561d6d5e7288384249"),
            "expected1");

    std::shared_ptr<libsnark::digest_variable<Field>> result1(
        new digest_variable<Field>(pb, Hash::get_digest_len(), "result"));

    PRF_rho_gadget<Field, Hash> prf_rho_gadget1(
        pb, ZERO, phi, hsig, size_t(1), result1);

    prf_rho_gadget1.generate_r1cs_constraints();
    prf_rho_gadget1.generate_r1cs_witness();

    bool is_valid_witness = pb.is_satisfied();
    ASSERT_TRUE(is_valid_witness);
    ASSERT_EQ(result0->get_digest(), rho_expected0.get_bits(pb));
    ASSERT_EQ(result1->get_digest(), rho_expected1.get_bits(pb));
}

} // namespace

int main(int argc, char **argv)
{
    // /!\ WARNING: Do once for all tests. Do not forget to do this !!!!
    pp::init_public_params();

    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
