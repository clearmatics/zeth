// Copyright (c) 2015-2022 Clearmatics Technologies Ltd
//
// SPDX-License-Identifier: LGPL-3.0+

#include "libzeth/circuits/mimc/mimc_mp.hpp"

#include <gtest/gtest.h>
#include <libff/algebra/curves/alt_bn128/alt_bn128_pp.hpp>
#include <libff/algebra/curves/bls12_377/bls12_377_pp.hpp>

using namespace libzeth;

template<typename FieldT>
using MiMCe17_round_gadget = MiMC_round_gadget<FieldT, 17>;
template<typename FieldT>
using MiMCe17_ALT_BN128_permutation_gadget =
    MiMC_permutation_gadget<FieldT, 17, 65>;
template<typename FieldT>
using MiMCe17_BLS12_377_permutation_gadget =
    MiMC_permutation_gadget<FieldT, 17, 62>;

namespace
{

TEST(TestMiMC, MiMC17_ALT_BN128_Round)
{
    using Field = libff::alt_bn128_Fr;

    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> in_x;
    libsnark::pb_variable<Field> in_k;
    libsnark::pb_variable<Field> result;

    in_x.allocate(pb, "x");
    in_k.allocate(pb, "k");
    result.allocate(pb, "result");

    // Test data from client test (test_mimc.py), to ensure consistency between
    // implementations.

    pb.val(in_x) = Field("340282366920938463463374607431768211456");
    pb.val(in_k) = Field("28948022309329048855892746252171976963317496166410141"
                         "009864396001978282409983");
    Field in_C = Field("1422006791884799603110814443576367281105075806594536430"
                       "8986253046354060608451");

    MiMCe17_round_gadget<Field> round_gadget(
        pb, in_x, in_k, in_C, result, "round_gadget");
    round_gadget.generate_r1cs_constraints();
    round_gadget.generate_r1cs_witness();

    Field expected_out = Field("15194574649778181158537940501307832704788048781"
                               "286507777438072456493095881604");
    ASSERT_TRUE(pb.is_satisfied());
    ASSERT_TRUE(expected_out == pb.val(result));
}

TEST(TestMiMC, MiMC17_ALT_BN128_Round_Incorrect)
{
    using Field = libff::alt_bn128_Fr;

    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> in_x;
    libsnark::pb_variable<Field> in_k;
    libsnark::pb_variable<Field> result;

    Field in_C = Field("12345");
    in_x.allocate(pb, "x");
    in_k.allocate(pb, "k");
    pb.val(in_x) = Field("67890");
    pb.val(in_k) = Field("98645");

    result.allocate(pb, "result");
    MiMCe17_round_gadget<Field> round_gadget(
        pb, in_x, in_k, in_C, result, "round_gadget");
    round_gadget.generate_r1cs_constraints();
    round_gadget.generate_r1cs_witness();

    // Force incorrect result value and check that circuit is not satisfied.
    pb.val(result) = Field("427778066313557225181231220812180094976");
    ASSERT_FALSE(pb.is_satisfied());
}

TEST(TestMiMC, MiMC17_ALT_BN128_Round_AddToResult)
{
    using Field = libff::alt_bn128_Fr;

    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> in_x;
    libsnark::pb_variable<Field> in_k;
    libsnark::pb_variable<Field> result;

    // Test data generated by:
    // $ python
    // >>> r =
    //   21888242871839275222246405745257275088548364400416034343698204186575808495617
    // >>> ((15212  + 98645 + 216319)**17) % r + 98645
    // 15395941923199146769662515429975727210847361451765447661089541693078496064650

    Field in_C = Field("216319");
    in_x.allocate(pb, "x");
    in_k.allocate(pb, "k");
    pb.val(in_x) = Field("15212");
    pb.val(in_k) = Field("98645");

    result.allocate(pb, "result");
    MiMCe17_round_gadget<Field> round_gadget(
        pb, in_x, in_k, in_C, result, in_k, "round_gadget");
    round_gadget.generate_r1cs_constraints();
    round_gadget.generate_r1cs_witness();

    Field expected_out = Field("15395941923199146769662515429975727210847361451"
                               "765447661089541693078496064650");
    ASSERT_TRUE(pb.is_satisfied());
    ASSERT_TRUE(expected_out == pb.val(result));
}

TEST(TestMiMC, MiMC17_ALT_BN128_Round_AddToResult_Incorrect)
{
    using Field = libff::alt_bn128_Fr;

    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> in_x;
    libsnark::pb_variable<Field> in_k;
    libsnark::pb_variable<Field> result;

    Field in_C = Field("12345");
    in_x.allocate(pb, "x");
    in_k.allocate(pb, "k");
    pb.val(in_x) = Field("67890");
    pb.val(in_k) = Field("98645");

    result.allocate(pb, "result");
    MiMCe17_round_gadget<Field> round_gadget(
        pb, in_x, in_k, in_C, result, in_k, "round_gadget");
    round_gadget.generate_r1cs_constraints();
    round_gadget.generate_r1cs_witness();

    // Force incorrect result value and check that circuit is not satisfied.
    pb.val(result) = Field("427778066313557225181231220812180193621");
    ASSERT_FALSE(pb.is_satisfied());
}

TEST(TestMiMC, MiMC17_ALT_BN128_Permutation)
{
    using Field = libff::alt_bn128_Fr;

    libsnark::protoboard<Field> pb;

    libsnark::pb_variable<Field> in_x;
    libsnark::pb_variable<Field> in_k;
    libsnark::pb_variable<Field> result;
    in_x.allocate(pb, "x");
    in_k.allocate(pb, "k");
    result.allocate(pb, "result");

    // Test data generated:
    // $ python
    // >>> import zeth.core.mimc
    // >>> MiMCAltBN128().encrypt(
    //   3703141493535563179657531719960160174296085208671919316200479060314459804651,
    //   15683951496311901749339509118960676303290224812129752890706581988986633412003)
    // 2950769369933203897475350343792407636840104781947445379481145971915829708697

    pb.val(in_x) = Field("3703141493535563179657531719960160174296085208671919"
                         "316200479060314459804651");
    pb.val(in_k) = Field("1568395149631190174933950911896067630329022481212975"
                         "2890706581988986633412003");

    MiMCe17_ALT_BN128_permutation_gadget<Field> mimc_perm_gadget(
        pb, in_x, in_k, result, "mimc_gadget");
    mimc_perm_gadget.generate_r1cs_constraints();
    mimc_perm_gadget.generate_r1cs_witness();

    Field expected_out = Field("29507693699332038974753503437924076368401047819"
                               "47445379481145971915829708697");
    ASSERT_TRUE(pb.is_satisfied());
    ASSERT_TRUE(expected_out == pb.val(result));
}

TEST(TestMiMC, MiMC17_ALT_BN128_Permutation_Incorrect)
{
    using Field = libff::alt_bn128_Fr;

    libsnark::protoboard<Field> pb;

    libsnark::pb_variable<Field> in_x;
    libsnark::pb_variable<Field> in_k;
    libsnark::pb_variable<Field> result;
    in_x.allocate(pb, "x");
    in_k.allocate(pb, "k");
    result.allocate(pb, "result");

    pb.val(in_x) = Field("3703141493535563179657531719960160174296085208671919"
                         "316200479060314459804651");
    pb.val(in_k) = Field("13455131405143248756924738814405142");

    MiMCe17_ALT_BN128_permutation_gadget<Field> mimc_gadget(
        pb, in_x, in_k, result, "mimc_gadget");
    mimc_gadget.generate_r1cs_constraints();
    mimc_gadget.generate_r1cs_witness();

    // Force invalid result
    pb.val(result) = Field("1929907233154780497731246912056983481156174"
                           "8095378968014959488920239255590840");
    ASSERT_FALSE(pb.is_satisfied());
}

TEST(TestMiMC, MiMC17_ALT_BN128_MP)
{
    using Field = libff::alt_bn128_Fr;

    // Test data from client test (test_mimc.py), to ensure consistency between
    // implementations.

    const Field m_val("340282366920938463463374607431768211456");
    const Field k_val("28948022309329048855892746252171976963317496166410141009"
                      "864396001978282409983");
    const Field h_val("14599678357063082723814206975733222579132256174923645170"
                      "354481857040188426666");

    libsnark::protoboard<Field> pb;

    // Public input
    libsnark::pb_variable<Field> k;
    k.allocate(pb, "k");
    pb.set_input_sizes(1);
    pb.val(k) = k_val;

    // Private inputs
    libsnark::pb_variable<Field> m;
    m.allocate(pb, "m");
    pb.val(m) = m_val;

    libsnark::pb_variable<Field> h;
    h.allocate(pb, "h");

    MiMC_mp_gadget<Field, MiMCe17_ALT_BN128_permutation_gadget<Field>>
        mimc_mp_gadget(pb, m, k, h, "mimc_mp");
    mimc_mp_gadget.generate_r1cs_constraints();
    mimc_mp_gadget.generate_r1cs_witness();

    // Check that the circuit is satisfied, and that the expected result is
    // generated.
    ASSERT_TRUE(pb.is_satisfied());
    ASSERT_EQ(h_val, pb.val(h));
}

TEST(TestMiMC, MiMC17_ALT_BN128_MP_Incorrect)
{
    using Field = libff::alt_bn128_Fr;

    // Test data from client test (test_mimc.py), to ensure consistency between
    // implementations.

    const Field m_val("340282366920938463463374607431768211456");
    const Field k_val("28948022309329048855892746252171976963317496166410141009"
                      "864396001978282409983");

    libsnark::protoboard<Field> pb;

    // Public input
    libsnark::pb_variable<Field> k;
    k.allocate(pb, "k");
    pb.set_input_sizes(1);
    pb.val(k) = k_val;

    // Private inputs
    libsnark::pb_variable<Field> m;
    m.allocate(pb, "m");
    pb.val(m) = m_val;

    libsnark::pb_variable<Field> h;
    h.allocate(pb, "h");

    MiMC_mp_gadget<Field, MiMCe17_ALT_BN128_permutation_gadget<Field>>
        mimc_mp_gadget(pb, m, k, h, "mimc_mp");
    mimc_mp_gadget.generate_r1cs_constraints();
    mimc_mp_gadget.generate_r1cs_witness();

    // Force incorrect result value and check that circuit is not satisfied.
    pb.val(h) = Field("145996783570630827238142069757332225791322561749236"
                      "45170354481857040188426667");
    ASSERT_FALSE(pb.is_satisfied());
}

TEST(TestMiMC, MiMC17_BLS12_377_Round)
{
    using Field = libff::bls12_377_Fr;

    libsnark::protoboard<Field> pb;
    libsnark::pb_variable<Field> in_x;
    libsnark::pb_variable<Field> in_k;
    libsnark::pb_variable<Field> result;

    in_x.allocate(pb, "x");
    in_k.allocate(pb, "k");
    result.allocate(pb, "result");

    // Test data from client test (test_mimc.py), to ensure consistency between
    // implementations.

    pb.val(in_x) = Field("340282366920938463463374607431768211456");
    pb.val(in_k) = Field("36146370610439375831462714358273373691897981609479495"
                         "26058695634226054692860");
    Field in_C = Field("5775606169419625606859319496982126279674858730791300481"
                       "051019590436651369410");

    MiMCe17_round_gadget<Field> round_gadget(
        pb, in_x, in_k, in_C, result, "round_gadget");
    round_gadget.generate_r1cs_constraints();
    round_gadget.generate_r1cs_witness();

    Field expected_out = Field("70652923384013840748711649474482841764205668417"
                               "1152884149736992660816802274");
    ASSERT_TRUE(pb.is_satisfied());
    ASSERT_EQ(expected_out, pb.val(result));
}

TEST(TestMiMC, MiMC17_BLS12_377_MP)
{
    using Field = libff::bls12_377_Fr;

    // Test data from client test (test_mimc.py), to ensure consistency between
    // implementations.

    const Field m_val(
        "361463706104393758314627143582733736918979816094794952605869"
        "5634226054692860");
    const Field k_val(
        "577560616941962560685931949698212627967485873079130048105101"
        "9590436651369410");
    const Field h_val(
        "580310635483157120553405751259383795319189070903739068091192"
        "5249983717812220");

    libsnark::protoboard<Field> pb;

    // Public input
    libsnark::pb_variable<Field> k;
    k.allocate(pb, "k");
    pb.set_input_sizes(1);
    pb.val(k) = k_val;

    // Private inputs
    libsnark::pb_variable<Field> m;
    m.allocate(pb, "m");
    pb.val(m) = m_val;

    libsnark::pb_variable<Field> h;
    h.allocate(pb, "h");

    MiMC_mp_gadget<Field, MiMCe17_BLS12_377_permutation_gadget<Field>>
        mimc_mp_gadget(pb, m, k, h, "mimc_mp");
    mimc_mp_gadget.generate_r1cs_constraints();
    mimc_mp_gadget.generate_r1cs_witness();

    // Check that the circuit is satisfied, and that the expected result is
    // generated.
    ASSERT_TRUE(pb.is_satisfied());
    ASSERT_EQ(h_val, pb.val(h));
}

} // namespace

int main(int argc, char **argv)
{
    // /!\ WARNING: Do once for all tests. Do not
    // forget to do this !!!!
    libff::alt_bn128_pp::init_public_params();
    libff::bls12_377_pp::init_public_params();

    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
