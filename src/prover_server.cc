#include <iostream>
#include <memory>
#include <string>
#include <stdio.h>

#include <grpc/grpc.h>
#include <grpcpp/server.h>
#include <grpcpp/server_builder.h>
#include <grpcpp/server_context.h>
#include <grpcpp/security/server_credentials.h>

// Necessary header to parse the data
#include <libsnark/common/data_structures/merkle_tree.hpp>

// Include zeth headers
#include "zeth.h"
#include "libsnark_helpers/libsnark_helpers.hpp"
#include "circuits/computation.hpp"
#include "circuits/sha256/sha256_ethereum.hpp"
#include "circuit-wrapper.hpp"
#include "zethConfig.h"

#include "util.hpp"

// Include the file generated by gRPC
#include "prover.grpc.pb.h"

using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::Status;
using grpc::StatusCode;

// Use the Prover service defined in the proto file
using proverpkg::Prover;

// Use the messages defined in the proto file
using proverpkg::EmptyMessage;
using proverpkg::PackedDigest;
using proverpkg::ProofInputs;
using proverpkg::HexadecimalPointBaseGroup1Affine;
using proverpkg::HexadecimalPointBaseGroup2Affine;
using proverpkg::VerificationKey;
using proverpkg::ExtendedProof;
using proverpkg::R1csPpzksnarkExtendedProof;
using proverpkg::R1csPpzksnarkVerificationKey;

typedef libff::default_ec_pp ppT;
typedef libff::Fr<ppT> FieldT;
typedef sha256_ethereum<FieldT> HashT;

libsnark::merkle_authentication_node ParseMerkleNode(std::string mk_node) {
  return libff::bit_vector(libzeth::hexadecimal_digest_to_binary_vector(mk_node));
}

libzeth::ZethNote ParseZethNote(const proverpkg::ZethNote& note) {
  bits256 noteAPK = libzeth::hexadecimal_digest_to_bits256(note.apk());
  bits64 noteValue = libzeth::hexadecimal_value_to_bits64(note.value());
  bits256 noteRho = libzeth::hexadecimal_digest_to_bits256(note.rho());
  bits384 noteTrapR = libzeth::get_bits384_from_vector(libzeth::hexadecimal_str_to_binary_vector(note.trapr()));

  return libzeth::ZethNote(
    noteAPK,
    noteValue,
    noteRho,
    noteTrapR
  );
}

libzeth::JSInput ParseJSInput(const proverpkg::JSInput& input) {
  if (ZETH_MERKLE_TREE_DEPTH != input.merklenode_size()) {
    throw std::invalid_argument("Invalid merkle path length");
  }

  libzeth::ZethNote inputNote = ParseZethNote(input.note());
  size_t inputAddress = input.address();
  bitsAddr inputAddressBits = libzeth::get_bitsAddr_from_vector(libzeth::address_bits_from_address(inputAddress, ZETH_MERKLE_TREE_DEPTH));
  bits256 inputSpendingASK = libzeth::hexadecimal_digest_to_bits256(input.spendingask());
  bits256 inputNullifier = libzeth::hexadecimal_digest_to_bits256(input.nullifier());

  std::vector<libsnark::merkle_authentication_node> inputMerklePath;
  for(int i = 0; i < ZETH_MERKLE_TREE_DEPTH; i++) {
    libsnark::merkle_authentication_node mk_node = ParseMerkleNode(input.merklenode(i));
    inputMerklePath.push_back(mk_node);
  }

  return libzeth::JSInput(
    inputMerklePath,
    inputAddress,
    inputAddressBits,
    inputNote,
    inputSpendingASK,
    inputNullifier
  );
}

HexadecimalPointBaseGroup1Affine FormatHexadecimalPointBaseGroup1Affine(libff::alt_bn128_G1 point) {
  libff::alt_bn128_G1 aff = point;
  aff.to_affine_coordinates();
  std::string xCoord = "0x" + HexStringFromLibsnarkBigint(aff.X.as_bigint());
  std::string yCoord = "0x" + HexStringFromLibsnarkBigint(aff.Y.as_bigint());

  HexadecimalPointBaseGroup1Affine res;
  res.set_xcoord(xCoord);
  res.set_ycoord(yCoord);

  return res;
}

HexadecimalPointBaseGroup2Affine FormatHexadecimalPointBaseGroup2Affine(libff::alt_bn128_G2 point) {
  libff::alt_bn128_G2 aff = point;
  aff.to_affine_coordinates();
  std::string xC1Coord = "0x" + HexStringFromLibsnarkBigint(aff.X.c1.as_bigint());
  std::string xC0Coord = "0x" + HexStringFromLibsnarkBigint(aff.X.c0.as_bigint());
  std::string yC1Coord = "0x" + HexStringFromLibsnarkBigint(aff.Y.c1.as_bigint());
  std::string yC0Coord = "0x" + HexStringFromLibsnarkBigint(aff.Y.c0.as_bigint());

  HexadecimalPointBaseGroup2Affine res;
  res.set_xc0coord(xC0Coord);
  res.set_xc1coord(xC1Coord);
  res.set_yc0coord(yC0Coord);
  res.set_yc1coord(yC1Coord);

  return res;
}

void PrepareProofResponse(extended_proof<ppT>& ext_proof, ExtendedProof* message) {
  libsnark::r1cs_ppzksnark_proof<ppT> proofObj = ext_proof.get_proof();

  HexadecimalPointBaseGroup1Affine *a = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *a_p = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup2Affine *b = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup1Affine *b_p = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *c = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *c_p = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *h = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *k = new HexadecimalPointBaseGroup1Affine();

  a->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_A.g));
  a_p->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_A.h));
  b->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(proofObj.g_B.g)); // in G2
  b_p->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_B.h));
  c->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_C.g));
  c_p->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_C.h));
  h->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_H));
  k->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_K));

  libsnark::r1cs_ppzksnark_primary_input<ppT> pubInputs = ext_proof.get_primary_input();
  std::stringstream ss;
  ss << "[";
  for (size_t i = 0; i < pubInputs.size(); ++i) {
    ss << "\"0x" << HexStringFromLibsnarkBigint(pubInputs[i].as_bigint()) << "\"";
    if ( i < pubInputs.size() - 1 ) {
        ss<< ", ";
    }
  }
  ss << "]";
  std::string inputs_json = ss.str();

  // Note on memory safety: set_allocated deleted the allocated objects
  // See: https://stackoverflow.com/questions/33960999/protobuf-will-set-allocated-delete-the-allocated-object
  R1csPpzksnarkExtendedProof *r1csPpzksnarkExtendedProof = message->mutable_r1csppzksnarkextendedproof();
  
  r1csPpzksnarkExtendedProof->set_allocated_a(a);
  r1csPpzksnarkExtendedProof->set_allocated_ap(a_p);
  r1csPpzksnarkExtendedProof->set_allocated_b(b);
  r1csPpzksnarkExtendedProof->set_allocated_bp(b_p);
  r1csPpzksnarkExtendedProof->set_allocated_c(c);
  r1csPpzksnarkExtendedProof->set_allocated_cp(c_p);
  r1csPpzksnarkExtendedProof->set_allocated_h(h);
  r1csPpzksnarkExtendedProof->set_allocated_k(k);
  r1csPpzksnarkExtendedProof->set_inputs(inputs_json);
}

void PrepareVerifyingKeyResponse(libsnark::r1cs_ppzksnark_verification_key<ppT>& vk, VerificationKey* message) {
  HexadecimalPointBaseGroup2Affine *a = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup1Affine *b = new HexadecimalPointBaseGroup1Affine(); // in G1
  HexadecimalPointBaseGroup2Affine *c = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup2Affine *g = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup1Affine *gb1 = new HexadecimalPointBaseGroup1Affine(); // in G1
  HexadecimalPointBaseGroup2Affine *gb2 = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup2Affine *z = new HexadecimalPointBaseGroup2Affine(); // in G2

  a->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.alphaA_g2)); // in G2
  b->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(vk.alphaB_g1)); // in G1
  c->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.alphaC_g2)); // in G2
  g->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.gamma_g2)); // in G2
  gb1->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(vk.gamma_beta_g1)); // in G1
  gb2->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.gamma_beta_g2)); // in G2
  z->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.rC_Z_g2)); // in G2

  std::stringstream ss;
  unsigned icLength = vk.encoded_IC_query.rest.indices.size() + 1;
  ss <<  "[[" << outputPointG1AffineAsHex(vk.encoded_IC_query.first) << "]";
  for (size_t i = 1; i < icLength; ++i) {
    auto vkICi = outputPointG1AffineAsHex(vk.encoded_IC_query.rest.values[i - 1]);
    ss << ",[" <<  vkICi << "]";
  }
  ss << "]";
  std::string IC_json = ss.str();

  // Note on memory safety: set_allocated deleted the allocated objects
  // See: https://stackoverflow.com/questions/33960999/protobuf-will-set-allocated-delete-the-allocated-object
  R1csPpzksnarkVerificationKey *r1csPpzksnarkVerificationKey = message->mutable_r1csppzksnarkverificationkey();

  r1csPpzksnarkVerificationKey->set_allocated_a(a);
  r1csPpzksnarkVerificationKey->set_allocated_b(b);
  r1csPpzksnarkVerificationKey->set_allocated_c(c);
  r1csPpzksnarkVerificationKey->set_allocated_g(g);
  r1csPpzksnarkVerificationKey->set_allocated_gb1(gb1);
  r1csPpzksnarkVerificationKey->set_allocated_gb2(gb2);
  r1csPpzksnarkVerificationKey->set_allocated_z(z);
  r1csPpzksnarkVerificationKey->set_ic(IC_json);
}

/*
void PrepareProofResponse(extended_proof<ppT, libsnark::r1cs_gg_ppzksnark_proof<ppT>>& ext_proof, ExtendedProof* message){
  
}

void PrepareVerifyingKeyResponse(libsnark::r1cs_gg_ppzksnark_verification_key<ppT>& vk, VerificationKey* message) {

}
*/
class ProverImpl final : public Prover::Service {//TODO abstract this
private:
  libzeth::CircuitWrapper<ZETH_NUM_JS_INPUTS, ZETH_NUM_JS_OUTPUTS> prover;
  keyPairT<ppT> keypair; // Result of the setup

public:
  explicit ProverImpl(
    libzeth::CircuitWrapper<ZETH_NUM_JS_INPUTS, ZETH_NUM_JS_OUTPUTS>& prover,
    keyPairT<ppT>& keypair
  ) : prover(prover), keypair(keypair) {}

  Status GetVerificationKey(
    ServerContext* context,
    const EmptyMessage* request,
    VerificationKey* response
  ) override {
    std::cout << "[ACK] Received the request to get the verification key" << std::endl;
    std::cout << "[DEBUG] Preparing verification key for response..." << std::endl;
    try {
      PrepareVerifyingKeyResponse(this->keypair.vk, response);
    } catch (const std::exception& e) {
      std::cout << "[ERROR] " << e.what() << std::endl;
      return ::grpc::Status(::grpc::StatusCode::INVALID_ARGUMENT, grpc::string(e.what()));
    } catch (...) {
      std::cout << "[ERROR] In catch all" << std::endl;
      return ::grpc::Status(::grpc::StatusCode::UNKNOWN, "");
    }

    return Status::OK;
  }

  Status Prove(
    ServerContext* context,
    const ProofInputs* proofInputs,
    ExtendedProof* proof
  ) override {
    std::cout << "[ACK] Received the request to generate a proof" << std::endl;
    std::cout << "[DEBUG] Parse received message to compute proof..." << std::endl;

    // Parse received message to feed to the prover
    try {
      libzeth::bits256 root_bits = libzeth::hexadecimal_digest_to_bits256(proofInputs->root());
      libzeth::bits64 vpub_in = libzeth::hexadecimal_value_to_bits64(proofInputs->inpubvalue());
      libzeth::bits64 vpub_out = libzeth::hexadecimal_value_to_bits64(proofInputs->outpubvalue());

      if (ZETH_NUM_JS_INPUTS != proofInputs->jsinputs_size()) {
        throw std::invalid_argument("Invalid number of JS inputs");
      }
      if (ZETH_NUM_JS_OUTPUTS != proofInputs->jsoutputs_size()) {
        throw std::invalid_argument("Invalid number of JS outputs");
      }

      std::cout << "[DEBUG] Process every inputs of the JoinSplit" << std::endl;
      std::array<libzeth::JSInput, ZETH_NUM_JS_INPUTS> jsInputs;
      for(int i = 0; i < ZETH_NUM_JS_INPUTS; i++) {
        proverpkg::JSInput receivedInput = proofInputs->jsinputs(i);
        libzeth::JSInput parsedInput = ParseJSInput(receivedInput);
        jsInputs[i] = parsedInput;
      }

      std::cout << "[DEBUG] Process every outputs of the JoinSplit" << std::endl;
      std::array<libzeth::ZethNote, ZETH_NUM_JS_OUTPUTS> jsOutputs;
      for(int i = 0; i < ZETH_NUM_JS_OUTPUTS; i++) {
        proverpkg::ZethNote receivedOutput = proofInputs->jsoutputs(i);
        libzeth::ZethNote parsedOutput = ParseZethNote(receivedOutput);
        jsOutputs[i] = parsedOutput;
      }
      typedef libsnark::r1cs_ppzksnark_proof<ppT> proofT;
      std::cout << "[DEBUG] Data parsed successfully" << std::endl;
      std::cout << "[DEBUG] Generating the proof..." << std::endl;
      extended_proof<ppT> ext_proof = this->prover.prove(
        root_bits,
        jsInputs,
        jsOutputs,
        vpub_in,
        vpub_out,
        this->keypair.pk
      );

      std::cout << "[DEBUG] Displaying the extended proof" << std::endl;
      ext_proof.dump_proof();
      ext_proof.dump_primary_inputs();

      std::cout << "[DEBUG] Preparing response..." << std::endl;
      PrepareProofResponse(ext_proof, proof);

    } catch (const std::exception& e) {
      std::cout << "[ERROR] " << e.what() << std::endl;
      return ::grpc::Status(::grpc::StatusCode::INVALID_ARGUMENT, grpc::string(e.what()));
    } catch (...) {
      std::cout << "[ERROR] In catch all" << std::endl;
      return ::grpc::Status(::grpc::StatusCode::UNKNOWN, "");
    }

    return Status::OK;
  }
};

std::string Version() {
  char buffer[100];
  int n;
  n = snprintf(buffer, 100, "Version %d.%d", ZETH_VERSION_MAJOR, ZETH_VERSION_MINOR); // Defined in the zethConfig file
  if (n < 0) {
      return "Version <Not specified>";
  }
  std::string version(buffer);
  return version;
}

void ServerStartMessage() {
  std::string copyright = "Copyright (c) 2015-2019 Clearmatics Technologies Ltd";
  std::string license = "SPDX-License-Identifier: LGPL-3.0+";
  std::string project = "R&D Department: PoC for Zerocash on Ethereum/Autonity";
  std::string version = Version();
  std::string warning = "**WARNING:** This code is a research-quality proof of concept, DO NOT use in production!";

  std::cout << "\n=====================================================" << std::endl;
  std::cout << copyright << std::endl;
  std::cout << license << std::endl;
  std::cout << project << std::endl;
  std::cout << version << std::endl;
  std::cout << warning << std::endl;
  std::cout << "=====================================================\n" << std::endl;
}

void RunServer(
  libzeth::CircuitWrapper<ZETH_NUM_JS_INPUTS, ZETH_NUM_JS_OUTPUTS>& prover,
  keyPairT<ppT>& keypair
) {
  // Listen for incoming connections on 0.0.0.0:50051
  std::string server_address("0.0.0.0:50051");

  ProverImpl service(prover, keypair);

  ServerBuilder builder;

  // Listen on the given address without any authentication mechanism.
  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());

  // Register "service" as the instance through which we'll communicate with
  // clients. In this case it corresponds to an *synchronous* service.
  builder.RegisterService(&service);

  // Finally assemble the server.
  std::unique_ptr<Server> server(builder.BuildAndStart());
  std::cout << "[DEBUG] Server listening on " << server_address << std::endl;

  // Wait for the server to shutdown. Note that some other thread must be
  // responsible for shutting down the server for this call to ever return.
  ServerStartMessage();
  server->Wait();
}

int main(int argc, char** argv) {
  // We inititalize the curve parameters here
  std::cout << "[DEBUG] Init params" << std::endl;
  ppT::init_public_params();

  std::cout << "[DEBUG] Run setup" << std::endl;
  libzeth::CircuitWrapper<ZETH_NUM_JS_INPUTS, ZETH_NUM_JS_OUTPUTS> prover;
  keyPairT<ppT> keypair = prover.generate_trusted_setup();

  std::cout << "[DEBUG] Setup successful, starting the server..." << std::endl;
  RunServer(prover, keypair);
  return 0;
}
