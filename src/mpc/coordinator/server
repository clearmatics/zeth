#!/usr/bin/env python3

"""
server command
"""

from coordinator.icontributionhandler import IContributionHandler
from coordinator.interval import Interval
from coordinator.server_state import Configuration, ServerState
from coordinator.upload_utils import handle_upload_request
from coordinator.crypto import \
    import_digest, export_verification_key, import_signature, verify
from typing import cast, Tuple
from flask import Flask, request, Response
from threading import Lock
import io
import time
from os import remove
from os.path import exists


CONFIGURATION_FILE = "server_config.json"
STATE_FILE = "server_state.json"
UPLOAD_FILE = "upload.raw"


def _write_state_file(state: ServerState, state_file: str) -> None:
    with open(state_file, "w") as state_f:
        state_f.write(state.to_json())


def run_server(handler: IContributionHandler) -> None:

    # Try to open config file and state file
    config: Configuration
    with open(CONFIGURATION_FILE, "r") as config_f:
        config = Configuration.from_json(config_f.read())

    state: ServerState
    if exists(STATE_FILE):
        print(f"run_server: using existing state file: {STATE_FILE}")
        with open(STATE_FILE, "r") as state_f:
            state = ServerState.from_json(state_f.read())
    else:
        state = ServerState.new(config)
        _write_state_file(state, STATE_FILE)

    # Util functions to handle state updates, call the handler exactly once
    # when the MPC has completed, and persist state as necessary
    handler_finalized = state.have_all_contributions()

    def _finalize_handler_once() -> None:
        nonlocal handler_finalized
        if (not handler_finalized) and state.have_all_contributions():
            handler_finalized = True
            handler.on_completed()

    def _update_state(now: float) -> None:
        if state.update(config, now):
            _finalize_handler_once()
            _write_state_file(state, STATE_FILE)

    def _on_contribution(now: float) -> None:
        state.received_contribution(config, now)
        _finalize_handler_once()
        _write_state_file(state, STATE_FILE)

    # Lock

    lock = Lock()

    # Server and end points
    server = Flask(__name__)

    @server.route('/challenge', methods=['GET'])
    def challenge() -> Response:
        lock.acquire()
        try:
            _update_state(time.time())
            if state.have_all_contributions():
                return Response("MPC is complete.  No remaining challenges", 405)

            challenge_file = handler.get_current_challenge_file()
            return Response(
                open(challenge_file, "rb"),
                mimetype="application/octet-stream")
        finally:
            lock.release()

    @server.route('/contribute', methods=['POST'])
    def contribute() -> Tuple[str, int]:
        lock.acquire()
        try:
            # Basic request check
            headers = request.headers
            # print(f"contribute: headers = {headers}")
            if 'Content-Length' not in headers:
                raise Exception("no Content-Length header")
            if 'Content-Type' not in headers:
                raise Exception("no Content-Type header")
            if 'X-MPC-Digest' not in headers:
                raise Exception("no X-MPC-Digest header")
            if 'X-MPC-Public-Key' not in headers:
                raise Exception("no X-MPC-Public-Key header")
            if 'X-MPC-Signature' not in headers:
                raise Exception("no X-MPC-Signature header")

            content_length = int(headers['Content-Length'])
            content_type = headers['Content-Type']
            digest = import_digest(headers.get('X-MPC-Digest'))
            pub_key_str = headers.get('X-MPC-Public-Key')
            sig = import_signature(headers.get('X-MPC-Signature'))
            # print(f"contribute: content_length = {content_length}")
            # print(f"contribute: pub_key_str = {pub_key_str}")
            # print(f"contribute: sig = {export_signature(sig)}")
            # print(f"contribute: content_type = {content_type}")

            boundary: str = ""
            for val in content_type.split("; "):
                if val.startswith("boundary="):
                    boundary = val[len("boundary="):]
                    break
            if not boundary:
                raise Exception("content-type contains no boundary")

            now = time.time()
            print(f"contribute: current time = {now}")

            # Update state using the current time and return an error if the
            # MPC is no longer active.
            _update_state(now)
            if state.have_all_contributions():
                return "MPC is complete.  No contributions accepted.", 405

            # Check that the public key matches the expected next contributor
            # (as text, rather than relying on comparison operators)
            contributor = config.contributors[state.next_contributor_index]
            pub_key = contributor.public_key
            expect_pub_key_str = export_verification_key(pub_key)
            if expect_pub_key_str != pub_key_str:
                return "contributor key does not match.", 403

            # Check signature correctness.  Ensures that the uploader is the
            # owner of the correct key BEFORE the costly file upload.  Gives
            # limited protection against DoS attacks (intentional or otherwise)
            # from people other than the next contributor.  (Note that this
            # pre-upload check requires the digest to be passed in the HTTP
            # header.)
            if not verify(sig, pub_key, digest):
                return "signature check failed", 403

            # Accept the upload (if the digest matches).  If successful, pass
            # the file to the handler.
            handle_upload_request(
                content_length,
                boundary,
                digest,
                cast(io.BufferedIOBase, request.stream),
                UPLOAD_FILE)

            if not handler.process_contribution(UPLOAD_FILE):
                raise Exception("contribution failed")

            now = time.time()
            _on_contribution(now)
            print(
                f"contribute: SUCCEEDED ({state.next_contributor_index} / " +
                f"{state.num_contributors} contribs), finished time = {now}")

        except Exception as ex:
            print(f"server_error: {ex}")
            return f"error: {ex}", 400

        finally:
            lock.release()
            # Remove the uploaded file if it is still there
            if exists(UPLOAD_FILE):
                remove(UPLOAD_FILE)

        return "OK", 200

    def _tick() -> None:
        lock.acquire()
        try:
            _update_state(time.time())
        finally:
            lock.release()

    interval = Interval(60.0, _tick)
    try:
        server.run(port=config.port, threaded=False)
    finally:
        print("Stopping ...", end='')
        interval.stop()
        print("DONE")


def test_main() -> int:
    from coordinator.null_contribution_handler import NullContributionHandler
    handler = NullContributionHandler()
    run_server(handler)
    return 0


if __name__ == "__main__":
    exit(test_main())
